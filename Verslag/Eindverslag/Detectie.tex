
\subsection{Kleuren} \label{Kleuren}
Het onderscheiden en detecteren van verschillende kleuren speelt een belangrijke rol in detectie van de schermen. Het waarnemen van een kleur aan de hand van een foto stemt echter niet altijd overeen met de afgebeelde kleur. De voornaamste oorzaken hiervan zijn lichtinval en reflectie. Tijdens detectie moet er dus rekening gehouden worden met deze factoren.

\subsubsection{Kleurmodellen en ruimtes}
Door de jaren heen zijn er heel veel verschillende modellen gemaakt om het visuele licht spectrum weer te geven. Al deze modellen hebben hun voordelen en nadelen en worden dan ook voor verschillende doeleinden gebruikt. De meest voorkomende modellen zijn RGB, CIE en HSL/HSV. Het RGB model is een additief kleurmodel waarbij een kleur wordt beschreven aan de hand van de drie primaire kleuren: rood, groen en blauw. Elke kleur kan dan gevormd worden aan de hand van een combinatie van deze drie kleuren. RGB wordt heel veel gebruikt in grafische toepassingen. Wanneer een foto door een computer wordt uitgelezen zal dit ook in RGB waardes gebeuren. Alleen zal dit model jammer genoeg niet gebruikt kunnen worden voor detectie omdat het model een niet-lineaire en discontinue ruimte vormt. Het is hierdoor moeilijk om een verandering in tint te beschrijven door zijn discontinuiteit. Ook verandert in het RGB model de tint gemakkelijk onder invloed van vaerandering van licht. CIE is gemaakt door de Commission Internationale de l'Éclairage (CIE). Het was het eerste model dat het mogelijk maakte om kleuren wiskundig voor te stellen. Het maakt gebruikt van de link tussen de verschillende golflengtes van het visueel spectrum en hoe mensen kleuren waarnemen. Het lag ook aan de basis voor bijna alle andere kleurmodellen die daarna uitgevonden zijn. Het grootste nadeel is dat het omzetten van RGB naar CIE een complex process is. Om deze reden wordt dit model niet gebruikt voor de detectie.  HSl en HSV maken allebei deel uit van het cylindrisch model. Deze worden beschreven in drie dimensies. Een hoek die de tint voorstelt gaande van 0\degree (rood), naar 120\degree (groen), richting 240\degree (blauw), om uiteindelijk bij 360\degree (rood) rond te zijn. Een horizontale dimensie die de saturatie beschrijft en een verticale dimensie die de lichtheid (HSL) of waarde (HSV) bepaald. Het grootste voordeel en de reden dat dit model gebruikt wordt over RGB en CIE is het feit dat deze modellen imuun zijn aan veranderingen in licht. Want deze zitten in een aparte dimensie. Een ander voordeel is ook dat de tint continue is in deze modellen. HSL wordt dan nog boven HSV verkozen door het feit dat HSL symmetrisch is voor licht en donker wat niet het geval is bij HSV.

\subsubsection{Ranges in de HSL kleurruimte} \label{Ranges}
Naast de keuze van het kleurmodel, HSl, moeten ook de kleuren voor detectie bepaald worden. Uiteindelijk heeft onze gebruikte methode zes verschillende kleuren nodig om te dedecteren. De keuze is gegaan naar de drie basiskleuren (rood, groen en blauw) aangevuld met de kleuren, die theoretisch het verst van elkaar verwijderd liggen op de cirkel (cyaan, magenta en geel). Bijgevolg liggen de gekozen kleuren allemaal op 60\degree van elkaar verwijderd. Vervolgens werd voor elke kleur een range bepaald onder verschillende omstandigheden. Hiervoor zijn foto's genomen van verschillende schermen in verschillende lichtomstandigheden en reflecties met verschillende camera's. Deze foto's dienen als dataset om de range van elke kleur te bepalen. Elke pixel van een foto werd uitgelezen en nadien omgezet van een RGB waarde naar een HSL waarde. Deze HSL waarden zijn vervolgens geplot in functie van tint en saturatie, alsook in functie van tint en lichtheid. De bekomen scatterplots toonden telkens een geconcentreerd gebied van datapunten aan dat aan de hand van lineaire functies begrensd werd. Deze lineaire functies worden dan gebruikt als range om de kleur te detecteren. Dit werd voor alle zes kleuren uitgevoerd.

\subsubsection{Verdere verbeteringen}
Uit de plots is echter gebleken dat aparte onderscheiding van zes verschillende kleuren geen goede optie is door overlap van de ranges van verschillende kleuren. Dit is het gevolg van zeer verschillende waarnemingen van een kleur naargelang de omstandigheden waarin een foto getrokken wordt. Het is dus niet mogelijk om zes verschillende kleuren correct te onderscheiden in alle omstandigheden. Nieuwe methodes moeten gevonden worden waar niet zoveel verschillende kleuren van elkaar onderscheiden moeten worden. Een eerste mogelijkheid is om een detectie uitgaande van slechts drie kleuren te verkiezen boven een detectie met zes kleuren. Bij het gebruik van een drie-kleuren-detectie zijn twee opties, waarbij de kleuren opnieuw zo ver mogelijk van elkaar verwijderd liggen (120\degree),  mogelijk. Eenderzijds het gebruik van de kleuren rood, groen en blauw of anderzijds de kleuren cyaan, magenta en geel. De uiteindelijke keuze valt op rood, groen en blauw aangezien deze minder ver fluctueren van de theoretische waarde dan cyaan, magenta en geel. Aan deze optie wordt reeds gewerkt om de detectie te verbeteren. Daarnaast is het ook een optie om eerder relatief naar het contrast tussen kleuren te kijken in plaats van detectie op basis van absolute ranges. Ook deze optie wordt reeds bekeken om de identificatie te verbeteren.

\subsection{Flood fill}
Elk individueel slave scherm laat een vooraf bepaalde afbeelding zien met gekende kleur-waarden (*afbeelding van html). Deze afbeelding voor detectie is een combinatie van vorige iteraties van het project. Het combineren van een border met een kruis geeft het meeste informatie over de associatie van de kleur-gefilterde pixels bij overlap of afgedekte delen van het scherm en bovendien meer informatie over de oriëntatie van het scherm op de foto. Om deze schermen te detecteren wordt de foto gefilterd op basis van gekende HSL ranges \ref{Ranges} en een standaard four-way flood fill algoritme [4 way afbeelding of te veel?] \cite{floodfill} om de associatie van de verbonden pixels te behouden. Na de executie van de flood fill is er voor elk gedetecteerd eiland een pixel masker met een unieke ID per eiland, opgeslagen in elke pixel, waar de verdere bewerkingen op uitgevoerd zullen worden. Het geimplementeerde floodfill algoritme groeit volgens de vier pixel-buren en een stack-based iteratie process om recursie-overflow tegen te gaan bij grote afbeeldingen en eilanden. In een worst-case scenario zal dit algoritme een eiland detecteren over de volledige afbeelding. Aangezien elke pixel maximaal vier keer in de stack terecht kan komen, door zijn vier buren, loopt deze flood fill volgens een tijdscomplexiteit van 
\[O(4mn)=O(mn)\]
 met m en n de dimensies van de afbeelding. De grootte van elk eiland zal in de praktijk over het algemeen een stuk kleiner zijn dan de volledige afbeelding.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{img/mask.png}
\caption{Kleurenmasker van een scherm na floodfill}
\end{figure}

Niet enkel de associatie van de gemaskeerde pixels wordt op deze manier behouden, maar deze methode maakt ook dat de komende bewerkingen maar over een minimale bounding box uitgevoerd worden ten opzichten van de volledige pixel matrix. Elk resulterend resultaat van floodfill geeft een verbonden pixel verzameling, een island, als resutlaat. De resulterende islands worden achteraf gefilterd opdat elk eiland de drie kleuren van de border en het middelpunt bevatten. Als er aan deze voorwaarde is voldaan is wordt er een poging gedaan om lokaal een middelpunt en geldige barcode te lezen \ref{barcode}. Bij het falen van een van deze verificatiestappen wordt het eiland verworpen, de overblijvende eilanden zijn geldige eilanden voor hoekdetectie.

\subsection{Hoekpunten}
Er werd vooraf een algemene hoek-detectie algoritme shi-tomashi geïmplementeerd en getest, maar gaf een te complex resultaat op de binaire maskers om de juiste hoeken te filteren. Dit algoritme draagt ook een relatief grote overhead door de x- en y-sobel operaties die elks een volledige pixel convolution over alle pixels in een eerste stap toepassen. Onze algoritmes zijn veel simplistischer en zullen in de praktijk nooit verder dan de boundary van een eiland uitgevoerd worden in tegenstelling tot de volledige island matrix, maar geven een perfect bruikbaar resultaat voor onze noden.

In de eerste stap wordt er bepaald of het scherm voornamelijk recht of gekanteld is ten opzichte van de foto. Hiervoor wordt langs de linker kant van het kader de standaarddeviatie van pixels in het masker berekend. Bij een standaardafwijking onder de 15\% wordt een scherm als liggend of verticaal gezien op de foto en niet gekanteld.\\
Als in eerste instantie het scherm als gedraaid beschouwd wordt, zal er vanuit elke rand van de bounding box van het eiland het de eerste mask-pixel als corner beschouwd worden. In het gev  al dat het scherm relatief horizontaal of verticaal recht staat, zal er loodrecht op de randen gezocht worden (zie figuur: \ref{fig:perp search}), maar volgens een diagonaal tot een mask-pixel (zie figuur: \ref{fig:diag search}).\\
\begin{figure}[h] 
\centering
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\textwidth]{img/perpSearch.png}
\caption{Loodrechte corner search}
\label{fig:perp search}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.9\textwidth]{img/diagSearch.png}
\caption{Diagonale corner search}
\label{fig:diag search}
\end{subfigure}
\caption{Hoekdetectie}
\end{figure}

Beide variaties van hoek-detectie zal altijd vier hoeken als resultaat opleveren. Dit zullen door overlap en foutjes in het maskeren niet altijd correcte hoeken zijn. Na het bepalen, worden de hoeken nagekeken of deze resultaten wel degelijk kwalificeren als hoek. Deze kwalificatie is gebaseerd op bepaalde eigenschappen die in de buurt van elke hoek moeten gevonden worden, namelijk twee lijnen die tot de boord behoren en een diagonaallijn die naar het middelpunt van het scherm loopt \ref{fig:correcte hoek}. Deze lijnen zijn bepaald door te filteren door de border- en diagonaal-kleur die gescheiden zijn door een witte rand (*beter verwijzen naar waar calccircle wordt uitgelegd in reconstructie?). Als in een eerder gevonden hoek deze voorwaarden niet aanwezig zijn, wordt deze hoek verworpen \ref{fig:foute hoek}.

\begin{figure}[h] 
\centering
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.6\textwidth]{img/correctCorner.png}
\caption{Een correcte hoek}
\label{fig:correcte hoek}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.6\textwidth]{img/notACorner.png}
\caption{Hoek zonder volledige features}
\label{fig:foute hoek}
\end{subfigure}
\caption{Hoekfiltering}
\end{figure}
(linken/binden naar reconstruction) Als er geen vier correcte hoeken gevonden worden, zullen missende hoeken gereconstrueerd worden uit de wel gevonden hoeken en het middelpunt.