
Schrijfhulp Academisch Nederlands
Gerealiseerd door het Instituut voor Levende Talen
Tekst
controleren
Tekst
verrijken

STRUCTUUR EN SAMENHANG
Tekstanalyse
Verwijswoorden
Signaal- en structuurwoorden
Frequente inhoudswoorden
Vaak terugkerende patronen
Zinslengte
Alinealengte

STIJL
Formele en archaïsche woorden
Passieven
Omslachtig taalgebruik
Naamwoordstijl
Vage en algemene woorden
Persoonlijk taalgebruik
Informele, spreektalige en gekleurde woorden

SPELLING
Spelfouten
Aaneenschrijven of niet?
Afkortingen


Gebruiker afmelden

Welkom op de website van de Schrijfhulp Nederlands. De schrijfhulp werd ontwikkeld om studenten te ondersteunen tijdens het schrijfproces.

De Schrijfhulp Nederlands wil je bewustmaken van mogelijke foutenpatronen in de tekst. De aangeduide woorden of woordcombinaties in de tekst zijn dus niet noodzakelijk fout. Omdat de schrijfhulp zich focust op de drie niveaus (structuur en samenhang, stijl en spelling) worden niet alle mogelijke schrijfproblemen aangeduid.

Aantal (tussen)titels in deze tekst:
Deze informatie is nodig om correcte statistieken te kunnen berekenen.
(Tussen)titels moeten van alinea’s gescheiden zijn door een 'harde' enter. Klik hier voor meer uitleg.

tekst verwerkt!

\subsection{Animatie met timers}

Een animatie wordt smooth bevonden als er geen frame ontbreekt tijdens het afspelen. Hoe meer frames er per seconde afgebeeld kunnen worden, hoe smoother de animatie oogt. Het gemiddelde consumer-device heeft een refresh rate van 60Hz wat overeenstemt met 60 frames per seconde (fps). Om een animatie zo smooth mogelijk te laten afspelen, wordt er dus over het algemeen gemikt naar een afspeelsnelheid van 60fps.

Om elke seconde 60 frames af te beelden moeten de frames volgens een correct getimed interval de volgende frame afbeelden. In javascript zijn hier twee build-in functies voor beschikbaar, \texttt{setTimeout()} en \texttt{setInterval()}. Op deze manier kan er met een timer om de 16.7ms een nieuwe frame afgebeeld worden om de 60fps playback snelheid te behalen.

\subsection{Problemen met timers}
Bij het gebruik maken van timers wordt er verondersteld van een playback van 60fps omdat de meeste schermen dit hanteren, maar als er een trager scherm gebruikt wordt om deze animatie af te beelden zullen er overtollige frames ingeladen worden niet gerenderd zullen worden door de browser. Een laadtijd van 16.7ms of minder voor elke frame is ook niet gegarandeerd en wordt verder besproken in \ref{performance}.

\paragraph{Drift in timers}Deze timers zouden er voor zorgen dat er elke gerenderde frame door de browser, de juiste frame van de animatie bevat. Dit kan niet aangenomen worden aangezien er altijd een kleine fout zal bestaan op de wachttijd tot de executie van de opgeroepen functie van de timer. Bij het uitvoeren van een test gebaseerd op \cite{testDrift} valt te constateren dat veel populaire browsers de kleine fout niet compenseren en daardoor begint op te tellen en als gevolg de globale timing van de animatie volledig zijn synchronisatie verliest.

\textbf{MAYBE MEER BROWSERS?}

\begin{figure} [H]
	\centering
	\includegraphics [width=0.7\textwidth] {img/Timer drift.png}
	\caption{Timer drift van verschillende populaire browsers} \label{drift}
\end{figure}

Door het continu opschuiven van frame updates kan er een framedrop voorkomen door redundante stappen van de animatie in te laden tijdens de foute frame waardoor de animatie stappen verliest en haperend ervaren wordt.

\paragraph{Single threaded}
Javascript wordt single-threaded in de browser uitgevoerd. Door deze limitatie kan een taak die getimed staat over x aantal milliseconden pas uitgevoerd worden op de main thread als de event loop op dat moment beschikbaar is om die functie dan uit te voeren. Als er tussen het initialiseren van de timer en het uitvoeren van deze geplande taak een andere taak tussenbeide komt die langere executietijd heeft dan de geplande tijd zal de uitvoering uitgesteld worden tot de event loop terug vrij komt. Ook dit is een deuk in de betrouwbaarheid van timers en kan voor framedrops zorgen als de executie te lang wordt uitgesteld tot voor de nieuwe repaint.

\begin{figure} [H]
	\centering
	\includegraphics [width=0.6\textwidth] {img/drift-framedrop.png}
	\caption{Framedrop door gebruik van setTimeout} \label{drift-framedrop}
	\source{https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution}
\end{figure}

\subsection{RequestAnimationFrame}

Een methode die moderne browsers bieden om animaties te updaten met javascript is \texttt{requestAnimationFrame()}. Het wordt in dezelfde context gebruikt als \texttt{setTimeout()}, maar lost enkele cruciale problemen op. Ten eerste moet er geen tijdsinterval meer gespecifieerd worden als parameter, maar synced de browser de executie van deze taak met de refreshrate van de monitor. De opgegeven callback functie wordt door de event loop net voor de repaint van de pagina uitgevoerd. Hierdoor worden enkel frames geüpdatet voor een repaint en zullen er geen redundante taken uitgevoerd worden per frame of framedrops voorkomen. \cite{requestFrameDocs}

\subsection{Performance} \label{performance}
Deze methode lost een groot deel van globale timing op, maar garandeert daarom geen smooth animation playback. We gaan er verder vanuit dat er geen devices een hogere refresh rate dan 60Hz verwachten en mikken dus op een playback snelheid van 60fps. Als de methode om de frame te updaten langer duurt dan 16.7ms zal de frame niet gedropt worden, maar uitgetrokken. Alle frames worden wel weergegeven, maar niet aan een snelheid van 60fps wat dus ook oogt als een niet vloeiende animatie.

\textbf{TODO}: performance bekijken met artif. workload (busy wait) en fps.

Om een pagina zo responsief mogelijk te houden, moet het aantal reflows geminimaliseerd worden. Er zijn nog verscheidene elementen die de reflow snelheid beïnvloeden zoals de diepte en afhankelijkheden van nodes in de DOM-tree van de webpagina. Aangezien er in dit geval enkel gewerkt wordt met een enkelvoudige animatie op een webpagina gaan we hier niet verder op in.
\cite{improvePerformance}

\subsection{HTTP request frames}

Voor deze test werd gebruik gemaakt van een sprite sheet met 15 frames op (figuur \ref{sheet}) en een animatie snelheid van 30 fps.

\begin{figure} [H]
	\centering
	\includegraphics [scale=0.7] {img/charging.png}
	\caption{Sprite sheet met 15 frames} \label{sheet}
\end{figure}

Bij de eerste test werdt de hele sprite sheet per frame ingeladen. Dit is om het effect te creëren dat de server elke frame genereert en doorstuurt naar de cliënt. Dit bleek zeer inefficiënt te zijn doordat de tijd om de frame op te halen met ethernet rond de 140 ms en met draadloos internet rond de 250 ms ligt (figuur \ref{draadloos} en figuur \ref{ethernet}).

\begin{figure} [H]
	\centering
	\begin{subfigure} [b] {0.45\textwidth}
		\centering
		\includegraphics [width=\textwidth] {img/draadloos.png}
		\caption{HTTP request met draadloze verbinding} \label{draadloos}
	\end{subfigure}
	\begin{subfigure} [b] {0.45\textwidth}
		\centering
		\includegraphics [width=\textwidth] {img/ethernet.png}
		\caption{HTTP request met ethernet verbinding} \label{ethernet}
	\end{subfigure}
\end{figure}

Hoewel de frames asynchroon worden ingeladen (figuur \ref{inladen}) is de animatie alles behalve ideaal. Door lange wachttijden zijn er veel frame skips en door de vele http requests wordt de verbinding gereset om de server niet te overbelasten met 30 requests per seconde (figuur \ref{reset}).

\begin{figure} [H]
	\centering
	\includegraphics [scale=0.3] {img/inladen.png}
	\caption{Inladen van elke frame} \label{inladen}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics [scale=0.7] {img/reset.png}
	\caption{Connection reset door teveel requests} \label{reset}
\end{figure}

Bij de tweede test werd gebruik gemaakt van een buffer. De sprite sheet werd om de 0.5 seconden ingeladen zodat elke frame tijd had om te displayen ($30 \frac{frames}{sec} \frac{1}{15 frames}=\frac{0.5}{sec} $). Dit creëert het effect dat de server 15 frames genereert en doorstuurt in 1 keer i.p.v. frame per frame. Dit is duidelijk een verbetering want de server krijgt 15 keer minder requests (figuur \ref{inladen2}) en er zijn geen frame skips meer. Na het inladen van de sheet zal de cliënt de 15 frames achter elkaar drawen zonder te hoeven wachten op de server. Daarna zal de volgende sheet (of buffer) gebruikt worden.

\begin{figure} [H]
	\centering
	\includegraphics [scale=0.7] {img/inladen2.png}
	\caption{Inladen van de buffer} \label{inladen2}
\end{figure}
